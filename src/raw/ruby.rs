use libc::{size_t, uint32_t};
use libc::types::os::arch::posix88::pid_t;
use std::os::unix::raw::{time_t, mode_t};
use libc::types::os::common::posix01::timeval;
pub type Struct_timeval = timeval;
pub type va_list = ();/* automatically generated by rust-bindgen */

pub type VALUE = ::libc::c_ulong;
pub type ID = ::libc::c_ulong;
pub type ruby_check_sizeof_int = [::libc::c_char; 1usize];
pub type ruby_check_sizeof_long = [::libc::c_char; 1usize];
pub type ruby_check_sizeof_long_long = [::libc::c_char; 1usize];
pub type ruby_check_sizeof_voidp = [::libc::c_char; 1usize];
pub type Enum_ruby_special_consts = ::libc::c_uint;
pub const RUBY_Qfalse: ::libc::c_uint = 0;
pub const RUBY_Qtrue: ::libc::c_uint = 20;
pub const RUBY_Qnil: ::libc::c_uint = 8;
pub const RUBY_Qundef: ::libc::c_uint = 52;
pub const RUBY_IMMEDIATE_MASK: ::libc::c_uint = 7;
pub const RUBY_FIXNUM_FLAG: ::libc::c_uint = 1;
pub const RUBY_FLONUM_MASK: ::libc::c_uint = 3;
pub const RUBY_FLONUM_FLAG: ::libc::c_uint = 2;
pub const RUBY_SYMBOL_FLAG: ::libc::c_uint = 12;
pub const RUBY_SPECIAL_SHIFT: ::libc::c_uint = 8;
pub type Enum_ruby_value_type = ::libc::c_uint;
pub const RUBY_T_NONE: ::libc::c_uint = 0;
pub const RUBY_T_OBJECT: ::libc::c_uint = 1;
pub const RUBY_T_CLASS: ::libc::c_uint = 2;
pub const RUBY_T_MODULE: ::libc::c_uint = 3;
pub const RUBY_T_FLOAT: ::libc::c_uint = 4;
pub const RUBY_T_STRING: ::libc::c_uint = 5;
pub const RUBY_T_REGEXP: ::libc::c_uint = 6;
pub const RUBY_T_ARRAY: ::libc::c_uint = 7;
pub const RUBY_T_HASH: ::libc::c_uint = 8;
pub const RUBY_T_STRUCT: ::libc::c_uint = 9;
pub const RUBY_T_BIGNUM: ::libc::c_uint = 10;
pub const RUBY_T_FILE: ::libc::c_uint = 11;
pub const RUBY_T_DATA: ::libc::c_uint = 12;
pub const RUBY_T_MATCH: ::libc::c_uint = 13;
pub const RUBY_T_COMPLEX: ::libc::c_uint = 14;
pub const RUBY_T_RATIONAL: ::libc::c_uint = 15;
pub const RUBY_T_NIL: ::libc::c_uint = 17;
pub const RUBY_T_TRUE: ::libc::c_uint = 18;
pub const RUBY_T_FALSE: ::libc::c_uint = 19;
pub const RUBY_T_SYMBOL: ::libc::c_uint = 20;
pub const RUBY_T_FIXNUM: ::libc::c_uint = 21;
pub const RUBY_T_UNDEF: ::libc::c_uint = 27;
pub const RUBY_T_NODE: ::libc::c_uint = 28;
pub const RUBY_T_ICLASS: ::libc::c_uint = 29;
pub const RUBY_T_ZOMBIE: ::libc::c_uint = 30;
pub const RUBY_T_MASK: ::libc::c_uint = 31;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RBasic {
    pub flags: VALUE,
    pub klass: VALUE,
}
impl ::std::clone::Clone for Struct_RBasic {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RBasic {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RObject {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed1,
}
impl ::std::clone::Clone for Struct_RObject {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RObject {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed1 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed1 {
    pub unsafe fn heap(&mut self) -> *mut Struct_Unnamed2 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ary(&mut self) -> *mut [VALUE; 3usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed2 {
    pub numiv: ::libc::c_long,
    pub ivptr: *mut VALUE,
    pub iv_index_tbl: *mut Struct_st_table,
}
impl ::std::clone::Clone for Struct_Unnamed2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_rb_classext_struct { }
pub type rb_classext_t = Struct_rb_classext_struct;
pub enum Struct_method_table_wrapper { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RClass {
    pub basic: Struct_RBasic,
    pub _super: VALUE,
    pub ptr: *mut rb_classext_t,
    pub m_tbl_wrapper: *mut Struct_method_table_wrapper,
}
impl ::std::clone::Clone for Struct_RClass {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RClass {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RString {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed3,
}
impl ::std::clone::Clone for Struct_RString {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RString {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed3 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed3 {
    pub unsafe fn heap(&mut self) -> *mut Struct_Unnamed4 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ary(&mut self) -> *mut [::libc::c_char; 24usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed4 {
    pub len: ::libc::c_long,
    pub ptr: *mut ::libc::c_char,
    pub aux: Union_Unnamed5,
}
impl ::std::clone::Clone for Struct_Unnamed4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed5 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed5 {
    pub unsafe fn capa(&mut self) -> *mut ::libc::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn shared(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed5 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed5 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RArray {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed6,
}
impl ::std::clone::Clone for Struct_RArray {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RArray {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed6 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed6 {
    pub unsafe fn heap(&mut self) -> *mut Struct_Unnamed7 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ary(&mut self) -> *mut [VALUE; 3usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed6 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed6 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed7 {
    pub len: ::libc::c_long,
    pub aux: Union_Unnamed8,
    pub ptr: *const VALUE,
}
impl ::std::clone::Clone for Struct_Unnamed7 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed7 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed8 {
    pub _bindgen_data_: [u64; 1usize],
}
impl Union_Unnamed8 {
    pub unsafe fn capa(&mut self) -> *mut ::libc::c_long {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn shared(&mut self) -> *mut VALUE {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed8 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed8 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_re_pattern_buffer { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RRegexp {
    pub basic: Struct_RBasic,
    pub ptr: *mut Struct_re_pattern_buffer,
    pub src: VALUE,
    pub usecnt: ::libc::c_ulong,
}
impl ::std::clone::Clone for Struct_RRegexp {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RRegexp {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_rb_io_t { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RFile {
    pub basic: Struct_RBasic,
    pub fptr: *mut Struct_rb_io_t,
}
impl ::std::clone::Clone for Struct_RFile {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RFile {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RData {
    pub basic: Struct_RBasic,
    pub dmark: ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void)
                                         -> ()>,
    pub dfree: ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void)
                                         -> ()>,
    pub data: *mut ::libc::c_void,
}
impl ::std::clone::Clone for Struct_RData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_data_type_t = Struct_rb_data_type_struct;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_rb_data_type_struct {
    pub wrap_struct_name: *const ::libc::c_char,
    pub function: Struct_Unnamed9,
    pub parent: *const rb_data_type_t,
    pub data: *mut ::libc::c_void,
    pub flags: VALUE,
}
impl ::std::clone::Clone for Struct_rb_data_type_struct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_rb_data_type_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed9 {
    pub dmark: ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void)
                                         -> ()>,
    pub dfree: ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void)
                                         -> ()>,
    pub dsize: ::std::option::Option<extern "C" fn(arg1:
                                                       *const ::libc::c_void)
                                         -> size_t>,
    pub reserved: [*mut ::libc::c_void; 2usize],
}
impl ::std::clone::Clone for Struct_Unnamed9 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed9 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RTypedData {
    pub basic: Struct_RBasic,
    pub _type: *const rb_data_type_t,
    pub typed_flag: VALUE,
    pub data: *mut ::libc::c_void,
}
impl ::std::clone::Clone for Struct_RTypedData {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RTypedData {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type RUBY_DATA_FUNC =
    ::std::option::Option<extern "C" fn(arg1: *mut ::libc::c_void) -> ()>;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_RStruct {
    pub basic: Struct_RBasic,
    pub _as: Union_Unnamed10,
}
impl ::std::clone::Clone for Struct_RStruct {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_RStruct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed10 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed10 {
    pub unsafe fn heap(&mut self) -> *mut Struct_Unnamed11 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn ary(&mut self) -> *mut [VALUE; 3usize] {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed10 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed10 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed11 {
    pub len: ::libc::c_long,
    pub ptr: *const VALUE,
}
impl ::std::clone::Clone for Struct_Unnamed11 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed11 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ruby_glob_func =
    extern "C" fn(arg1: *const ::libc::c_char, arg2: VALUE,
                  arg3: *mut ::libc::c_void) -> ::libc::c_int;
pub enum Struct_rb_global_variable { }
pub type rb_gvar_getter_t =
    extern "C" fn(id: ID, data: *mut ::libc::c_void,
                  gvar: *mut Struct_rb_global_variable) -> VALUE;
pub type rb_gvar_setter_t =
    extern "C" fn(val: VALUE, id: ID, data: *mut ::libc::c_void,
                  gvar: *mut Struct_rb_global_variable) -> ();
pub type rb_gvar_marker_t = extern "C" fn(var: *mut VALUE) -> ();
pub type rb_block_call_func =
    extern "C" fn(yielded_arg: VALUE, callback_arg: VALUE,
                  argc: ::libc::c_int, argv: *const VALUE, blockarg: VALUE)
        -> VALUE;
pub type rb_block_call_func_t =
    ::std::option::Option<extern "C" fn() -> VALUE>;
pub type st_data_t = ::libc::c_ulong;
pub type st_table = Struct_st_table;
pub type st_index_t = st_data_t;
pub type st_compare_func =
    extern "C" fn(arg1: st_data_t, arg2: st_data_t) -> ::libc::c_int;
pub type st_hash_func = extern "C" fn(arg1: st_data_t) -> st_index_t;
pub type st_check_for_sizeof_st_index_t = [::libc::c_char; 1usize];
#[repr(C)]
#[derive(Copy)]
pub struct Struct_st_hash_type {
    pub compare: ::std::option::Option<extern "C" fn() -> ::libc::c_int>,
    pub hash: ::std::option::Option<extern "C" fn() -> st_index_t>,
}
impl ::std::clone::Clone for Struct_st_hash_type {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_st_hash_type {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_st_table_entry { }
pub enum Struct_st_packed_entry { }
#[repr(C)]
#[derive(Copy)]
pub struct Struct_st_table {
    pub _type: *const Struct_st_hash_type,
    pub num_bins: st_index_t,
    pub _bindgen_bitfield_1_: ::libc::c_uint,
    pub _bindgen_bitfield_2_: st_index_t,
    pub _as: Union_Unnamed12,
}
impl ::std::clone::Clone for Struct_st_table {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_st_table {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed12 {
    pub _bindgen_data_: [u64; 3usize],
}
impl Union_Unnamed12 {
    pub unsafe fn big(&mut self) -> *mut Struct_Unnamed13 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn packed(&mut self) -> *mut Struct_Unnamed14 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed12 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed12 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed13 {
    pub bins: *mut *mut Struct_st_table_entry,
    pub head: *mut Struct_st_table_entry,
    pub tail: *mut Struct_st_table_entry,
}
impl ::std::clone::Clone for Struct_Unnamed13 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed13 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed14 {
    pub entries: *mut Struct_st_packed_entry,
    pub real_entries: st_index_t,
}
impl ::std::clone::Clone for Struct_Unnamed14 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed14 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_st_retval = ::libc::c_uint;
pub const ST_CONTINUE: ::libc::c_uint = 0;
pub const ST_STOP: ::libc::c_uint = 1;
pub const ST_DELETE: ::libc::c_uint = 2;
pub const ST_CHECK: ::libc::c_uint = 3;
pub type st_update_callback_func =
    extern "C" fn(key: *mut st_data_t, value: *mut st_data_t, arg: st_data_t,
                  existing: ::libc::c_int) -> ::libc::c_int;
pub type rb_enumerator_size_func =
    extern "C" fn(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed15 {
    pub maxfd: ::libc::c_int,
    pub fdset: *mut fd_set,
}
impl ::std::clone::Clone for Struct_Unnamed15 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed15 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type rb_fdset_t = Struct_Unnamed15;
pub type rb_alloc_func_t =
    ::std::option::Option<extern "C" fn(arg1: VALUE) -> VALUE>;
pub type rb_hash_update_func =
    extern "C" fn(newkey: VALUE, oldkey: VALUE, value: VALUE) -> VALUE;
pub type rb_unblock_function_t =
    extern "C" fn(arg1: *mut ::libc::c_void) -> ();
pub type rb_blocking_function_t =
    extern "C" fn(arg1: *mut ::libc::c_void) -> VALUE;
pub type rb_event_flag_t = uint32_t;
pub type rb_event_hook_func_t =
    ::std::option::Option<extern "C" fn(evflag: rb_event_flag_t, data: VALUE,
                                        _self: VALUE, mid: ID, klass: VALUE)
                              -> ()>;
#[link(name = "ruby", kind = "framework")]
extern "C" {
    pub static mut rb_mKernel: VALUE;
    pub static mut rb_mComparable: VALUE;
    pub static mut rb_mEnumerable: VALUE;
    pub static mut rb_mErrno: VALUE;
    pub static mut rb_mFileTest: VALUE;
    pub static mut rb_mGC: VALUE;
    pub static mut rb_mMath: VALUE;
    pub static mut rb_mProcess: VALUE;
    pub static mut rb_mWaitReadable: VALUE;
    pub static mut rb_mWaitWritable: VALUE;
    pub static mut rb_cBasicObject: VALUE;
    pub static mut rb_cObject: VALUE;
    pub static mut rb_cArray: VALUE;
    pub static mut rb_cBignum: VALUE;
    pub static mut rb_cBinding: VALUE;
    pub static mut rb_cClass: VALUE;
    pub static mut rb_cCont: VALUE;
    pub static mut rb_cDir: VALUE;
    pub static mut rb_cData: VALUE;
    pub static mut rb_cFalseClass: VALUE;
    pub static mut rb_cEncoding: VALUE;
    pub static mut rb_cEnumerator: VALUE;
    pub static mut rb_cFile: VALUE;
    pub static mut rb_cFixnum: VALUE;
    pub static mut rb_cFloat: VALUE;
    pub static mut rb_cHash: VALUE;
    pub static mut rb_cInteger: VALUE;
    pub static mut rb_cIO: VALUE;
    pub static mut rb_cMatch: VALUE;
    pub static mut rb_cMethod: VALUE;
    pub static mut rb_cModule: VALUE;
    pub static mut rb_cNameErrorMesg: VALUE;
    pub static mut rb_cNilClass: VALUE;
    pub static mut rb_cNumeric: VALUE;
    pub static mut rb_cProc: VALUE;
    pub static mut rb_cRandom: VALUE;
    pub static mut rb_cRange: VALUE;
    pub static mut rb_cRational: VALUE;
    pub static mut rb_cComplex: VALUE;
    pub static mut rb_cRegexp: VALUE;
    pub static mut rb_cStat: VALUE;
    pub static mut rb_cString: VALUE;
    pub static mut rb_cStruct: VALUE;
    pub static mut rb_cSymbol: VALUE;
    pub static mut rb_cThread: VALUE;
    pub static mut rb_cTime: VALUE;
    pub static mut rb_cTrueClass: VALUE;
    pub static mut rb_cUnboundMethod: VALUE;
    pub static mut rb_eException: VALUE;
    pub static mut rb_eStandardError: VALUE;
    pub static mut rb_eSystemExit: VALUE;
    pub static mut rb_eInterrupt: VALUE;
    pub static mut rb_eSignal: VALUE;
    pub static mut rb_eFatal: VALUE;
    pub static mut rb_eArgError: VALUE;
    pub static mut rb_eEOFError: VALUE;
    pub static mut rb_eIndexError: VALUE;
    pub static mut rb_eStopIteration: VALUE;
    pub static mut rb_eKeyError: VALUE;
    pub static mut rb_eRangeError: VALUE;
    pub static mut rb_eIOError: VALUE;
    pub static mut rb_eRuntimeError: VALUE;
    pub static mut rb_eSecurityError: VALUE;
    pub static mut rb_eSystemCallError: VALUE;
    pub static mut rb_eThreadError: VALUE;
    pub static mut rb_eTypeError: VALUE;
    pub static mut rb_eZeroDivError: VALUE;
    pub static mut rb_eNotImpError: VALUE;
    pub static mut rb_eNoMemError: VALUE;
    pub static mut rb_eNoMethodError: VALUE;
    pub static mut rb_eFloatDomainError: VALUE;
    pub static mut rb_eLocalJumpError: VALUE;
    pub static mut rb_eSysStackError: VALUE;
    pub static mut rb_eRegexpError: VALUE;
    pub static mut rb_eEncodingError: VALUE;
    pub static mut rb_eEncCompatError: VALUE;
    pub static mut rb_eScriptError: VALUE;
    pub static mut rb_eNameError: VALUE;
    pub static mut rb_eSyntaxError: VALUE;
    pub static mut rb_eLoadError: VALUE;
    pub static mut rb_eMathDomainError: VALUE;
    pub static mut rb_stdin: VALUE;
    pub static mut rb_stdout: VALUE;
    pub static mut rb_stderr: VALUE;
    pub static mut rb_fs: VALUE;
    pub static mut rb_output_fs: VALUE;
    pub static mut rb_rs: VALUE;
    pub static mut rb_default_rs: VALUE;
    pub static mut rb_output_rs: VALUE;
    pub static mut ruby_sourceline: ::libc::c_int;
    pub static mut ruby_sourcefile: *mut ::libc::c_char;
    pub static mut rb_argv0: VALUE;
}
#[link(name = "ruby", kind = "framework")]
extern "C" {
    pub fn pselect(arg1: ::libc::c_int, arg2: *mut fd_set, arg3: *mut fd_set,
                   arg4: *mut fd_set, arg5: *const Struct_timespec,
                   arg6: *const sigset_t) -> ::libc::c_int;
    pub fn select(arg1: ::libc::c_int, arg2: *mut fd_set, arg3: *mut fd_set,
                  arg4: *mut fd_set, arg5: *mut Struct_timeval)
     -> ::libc::c_int;
    pub fn eaccess(arg1: *const ::libc::c_char, arg2: ::libc::c_int)
     -> ::libc::c_int;
    pub fn setproctitle(fmt: *const ::libc::c_char, ...) -> ();
    pub fn ruby_xmalloc(arg1: size_t) -> *mut ::libc::c_void;
    pub fn ruby_xmalloc2(arg1: size_t, arg2: size_t) -> *mut ::libc::c_void;
    pub fn ruby_xcalloc(arg1: size_t, arg2: size_t) -> *mut ::libc::c_void;
    pub fn ruby_xrealloc(arg1: *mut ::libc::c_void, arg2: size_t)
     -> *mut ::libc::c_void;
    pub fn ruby_xrealloc2(arg1: *mut ::libc::c_void, arg2: size_t,
                          arg3: size_t) -> *mut ::libc::c_void;
    pub fn ruby_xfree(arg1: *mut ::libc::c_void) -> ();
    pub fn rb_int2inum(arg1: ::libc::c_long) -> VALUE;
    pub fn rb_uint2inum(arg1: VALUE) -> VALUE;
    pub fn rb_ll2inum(arg1: ::libc::c_longlong) -> VALUE;
    pub fn rb_ull2inum(arg1: ::libc::c_ulonglong) -> VALUE;
    pub fn rb_out_of_int(num: ::libc::c_long) -> ();
    pub fn rb_sym2id(arg1: VALUE) -> ID;
    pub fn rb_id2sym(arg1: ID) -> VALUE;
    pub fn rb_check_type(arg1: VALUE, arg2: ::libc::c_int) -> ();
    pub fn rb_str_to_str(arg1: VALUE) -> VALUE;
    pub fn rb_string_value(arg1: *mut VALUE) -> VALUE;
    pub fn rb_string_value_ptr(arg1: *mut VALUE) -> *mut ::libc::c_char;
    pub fn rb_string_value_cstr(arg1: *mut VALUE) -> *mut ::libc::c_char;
    pub fn rb_check_safe_obj(arg1: VALUE) -> ();
    pub fn rb_str_export(arg1: VALUE) -> VALUE;
    pub fn rb_str_export_locale(arg1: VALUE) -> VALUE;
    pub fn rb_get_path(arg1: VALUE) -> VALUE;
    pub fn rb_get_path_no_checksafe(arg1: VALUE) -> VALUE;
    pub fn rb_secure(arg1: ::libc::c_int) -> ();
    pub fn rb_safe_level() -> ::libc::c_int;
    pub fn rb_set_safe_level(arg1: ::libc::c_int) -> ();
    pub fn rb_set_safe_level_force(arg1: ::libc::c_int) -> ();
    pub fn rb_secure_update(arg1: VALUE) -> ();
    pub fn rb_insecure_operation() -> ();
    pub fn rb_errinfo() -> VALUE;
    pub fn rb_set_errinfo(arg1: VALUE) -> ();
    pub fn rb_num2long(arg1: VALUE) -> ::libc::c_long;
    pub fn rb_num2ulong(arg1: VALUE) -> ::libc::c_ulong;
    pub fn rb_num2int(arg1: VALUE) -> ::libc::c_long;
    pub fn rb_fix2int(arg1: VALUE) -> ::libc::c_long;
    pub fn rb_num2uint(arg1: VALUE) -> ::libc::c_ulong;
    pub fn rb_fix2uint(arg1: VALUE) -> ::libc::c_ulong;
    pub fn rb_num2short(arg1: VALUE) -> ::libc::c_short;
    pub fn rb_num2ushort(arg1: VALUE) -> ::libc::c_ushort;
    pub fn rb_fix2short(arg1: VALUE) -> ::libc::c_short;
    pub fn rb_fix2ushort(arg1: VALUE) -> ::libc::c_ushort;
    pub fn rb_num2ll(arg1: VALUE) -> ::libc::c_longlong;
    pub fn rb_num2ull(arg1: VALUE) -> ::libc::c_ulonglong;
    pub fn rb_num2dbl(arg1: VALUE) -> ::libc::c_double;
    pub fn rb_uint2big(arg1: VALUE) -> VALUE;
    pub fn rb_int2big(arg1: ::libc::c_long) -> VALUE;
    pub fn rb_newobj() -> VALUE;
    pub fn rb_newobj_of(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_setup(obj: VALUE, klass: VALUE, _type: VALUE) -> VALUE;
    pub fn rb_obj_hide(obj: VALUE) -> VALUE;
    pub fn rb_obj_reveal(obj: VALUE, klass: VALUE) -> VALUE;
    pub fn rb_float_value(arg1: VALUE) -> ::libc::c_double;
    pub fn rb_float_new(arg1: ::libc::c_double) -> VALUE;
    pub fn rb_float_new_in_heap(arg1: ::libc::c_double) -> VALUE;
    pub fn rb_data_object_alloc(arg1: VALUE, arg2: *mut ::libc::c_void,
                                arg3: RUBY_DATA_FUNC, arg4: RUBY_DATA_FUNC)
     -> VALUE;
    pub fn rb_data_typed_object_alloc(klass: VALUE,
                                      datap: *mut ::libc::c_void,
                                      arg1: *const rb_data_type_t) -> VALUE;
    pub fn rb_typeddata_inherited_p(child: *const rb_data_type_t,
                                    parent: *const rb_data_type_t)
     -> ::libc::c_int;
    pub fn rb_typeddata_is_kind_of(arg1: VALUE, arg2: *const rb_data_type_t)
     -> ::libc::c_int;
    pub fn rb_check_typeddata(arg1: VALUE, arg2: *const rb_data_type_t)
     -> *mut ::libc::c_void;
    pub fn rb_freeze_singleton_class(klass: VALUE) -> ();
    pub fn rb_gc_writebarrier_incremental(a: VALUE, b: VALUE)
     -> ::libc::c_int;
    pub fn rb_gc_writebarrier_generational(a: VALUE, b: VALUE) -> ();
    pub fn rb_gc_writebarrier_unprotect(obj: VALUE) -> ();
    pub fn rb_alloc_tmp_buffer(store: *mut VALUE, len: ::libc::c_long)
     -> *mut ::libc::c_void;
    pub fn rb_free_tmp_buffer(store: *mut VALUE) -> ();
    pub fn rb_obj_infect(arg1: VALUE, arg2: VALUE) -> ();
    pub fn rb_glob(arg1: *const ::libc::c_char,
                   arg2:
                       ::std::option::Option<extern "C" fn(arg1:
                                                               *const ::libc::c_char,
                                                           arg2: VALUE,
                                                           arg3:
                                                               *mut ::libc::c_void)
                                                 -> ()>, arg3: VALUE) -> ();
    pub fn ruby_glob(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                     arg3:
                         *mut ::std::option::Option<extern "C" fn()
                                                        -> ::libc::c_int>,
                     arg4: VALUE) -> ::libc::c_int;
    pub fn ruby_brace_glob(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                           arg3:
                               *mut ::std::option::Option<extern "C" fn()
                                                              ->
                                                                  ::libc::c_int>,
                           arg4: VALUE) -> ::libc::c_int;
    pub fn rb_define_class(arg1: *const ::libc::c_char, arg2: VALUE) -> VALUE;
    pub fn rb_define_module(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_define_class_under(arg1: VALUE, arg2: *const ::libc::c_char,
                                 arg3: VALUE) -> VALUE;
    pub fn rb_define_module_under(arg1: VALUE, arg2: *const ::libc::c_char)
     -> VALUE;
    pub fn rb_include_module(arg1: VALUE, arg2: VALUE) -> ();
    pub fn rb_extend_object(arg1: VALUE, arg2: VALUE) -> ();
    pub fn rb_prepend_module(arg1: VALUE, arg2: VALUE) -> ();
    pub fn rb_gvar_undef_getter(id: ID, data: *mut ::libc::c_void,
                                gvar: *mut Struct_rb_global_variable)
     -> VALUE;
    pub fn rb_gvar_undef_setter(val: VALUE, id: ID, data: *mut ::libc::c_void,
                                gvar: *mut Struct_rb_global_variable) -> ();
    pub fn rb_gvar_undef_marker(var: *mut VALUE) -> ();
    pub fn rb_gvar_val_getter(id: ID, data: *mut ::libc::c_void,
                              gvar: *mut Struct_rb_global_variable) -> VALUE;
    pub fn rb_gvar_val_setter(val: VALUE, id: ID, data: *mut ::libc::c_void,
                              gvar: *mut Struct_rb_global_variable) -> ();
    pub fn rb_gvar_val_marker(var: *mut VALUE) -> ();
    pub fn rb_gvar_var_getter(id: ID, data: *mut ::libc::c_void,
                              gvar: *mut Struct_rb_global_variable) -> VALUE;
    pub fn rb_gvar_var_setter(val: VALUE, id: ID, data: *mut ::libc::c_void,
                              gvar: *mut Struct_rb_global_variable) -> ();
    pub fn rb_gvar_var_marker(var: *mut VALUE) -> ();
    pub fn rb_gvar_readonly_setter(val: VALUE, id: ID,
                                   data: *mut ::libc::c_void,
                                   gvar: *mut Struct_rb_global_variable)
     -> ();
    pub fn rb_define_variable(arg1: *const ::libc::c_char, arg2: *mut VALUE)
     -> ();
    pub fn rb_define_virtual_variable(arg1: *const ::libc::c_char,
                                      arg2:
                                          ::std::option::Option<extern "C" fn()
                                                                    -> VALUE>,
                                      arg3:
                                          ::std::option::Option<extern "C" fn()
                                                                    -> ()>)
     -> ();
    pub fn rb_define_hooked_variable(arg1: *const ::libc::c_char,
                                     arg2: *mut VALUE,
                                     arg3:
                                         ::std::option::Option<extern "C" fn()
                                                                   -> VALUE>,
                                     arg4:
                                         ::std::option::Option<extern "C" fn()
                                                                   -> ()>)
     -> ();
    pub fn rb_define_readonly_variable(arg1: *const ::libc::c_char,
                                       arg2: *const VALUE) -> ();
    pub fn rb_define_const(arg1: VALUE, arg2: *const ::libc::c_char,
                           arg3: VALUE) -> ();
    pub fn rb_define_global_const(arg1: *const ::libc::c_char, arg2: VALUE)
     -> ();
    pub fn rb_define_method(arg1: VALUE, arg2: *const ::libc::c_char,
                            arg3:
                                ::std::option::Option<extern "C" fn()
                                                          -> VALUE>,
                            arg4: ::libc::c_int) -> ();
    pub fn rb_define_module_function(arg1: VALUE, arg2: *const ::libc::c_char,
                                     arg3:
                                         ::std::option::Option<extern "C" fn()
                                                                   -> VALUE>,
                                     arg4: ::libc::c_int) -> ();
    pub fn rb_define_global_function(arg1: *const ::libc::c_char,
                                     arg2:
                                         ::std::option::Option<extern "C" fn()
                                                                   -> VALUE>,
                                     arg3: ::libc::c_int) -> ();
    pub fn rb_undef_method(arg1: VALUE, arg2: *const ::libc::c_char) -> ();
    pub fn rb_define_alias(arg1: VALUE, arg2: *const ::libc::c_char,
                           arg3: *const ::libc::c_char) -> ();
    pub fn rb_define_attr(arg1: VALUE, arg2: *const ::libc::c_char,
                          arg3: ::libc::c_int, arg4: ::libc::c_int) -> ();
    pub fn rb_global_variable(arg1: *mut VALUE) -> ();
    pub fn rb_gc_register_mark_object(arg1: VALUE) -> ();
    pub fn rb_gc_register_address(arg1: *mut VALUE) -> ();
    pub fn rb_gc_unregister_address(arg1: *mut VALUE) -> ();
    pub fn rb_intern(arg1: *const ::libc::c_char) -> ID;
    pub fn rb_intern2(arg1: *const ::libc::c_char, arg2: ::libc::c_long)
     -> ID;
    pub fn rb_intern_str(str: VALUE) -> ID;
    pub fn rb_id2name(arg1: ID) -> *const ::libc::c_char;
    pub fn rb_check_id(arg1: *mut VALUE) -> ID;
    pub fn rb_to_id(arg1: VALUE) -> ID;
    pub fn rb_id2str(arg1: ID) -> VALUE;
    pub fn rb_sym2str(arg1: VALUE) -> VALUE;
    pub fn rb_to_symbol(name: VALUE) -> VALUE;
    pub fn rb_check_symbol(namep: *mut VALUE) -> VALUE;
    pub fn rb_class2name(arg1: VALUE) -> *const ::libc::c_char;
    pub fn rb_obj_classname(arg1: VALUE) -> *const ::libc::c_char;
    pub fn rb_p(arg1: VALUE) -> ();
    pub fn rb_eval_string(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_eval_string_protect(arg1: *const ::libc::c_char,
                                  arg2: *mut ::libc::c_int) -> VALUE;
    pub fn rb_eval_string_wrap(arg1: *const ::libc::c_char,
                               arg2: *mut ::libc::c_int) -> VALUE;
    pub fn rb_funcall(arg1: VALUE, arg2: ID, arg3: ::libc::c_int, ...)
     -> VALUE;
    pub fn rb_funcallv(arg1: VALUE, arg2: ID, arg3: ::libc::c_int,
                       arg4: *const VALUE) -> VALUE;
    pub fn rb_funcallv_public(arg1: VALUE, arg2: ID, arg3: ::libc::c_int,
                              arg4: *const VALUE) -> VALUE;
    pub fn rb_funcall_passing_block(arg1: VALUE, arg2: ID,
                                    arg3: ::libc::c_int, arg4: *const VALUE)
     -> VALUE;
    pub fn rb_funcall_with_block(arg1: VALUE, arg2: ID, arg3: ::libc::c_int,
                                 arg4: *const VALUE, arg5: VALUE) -> VALUE;
    pub fn rb_scan_args(arg1: ::libc::c_int, arg2: *const VALUE,
                        arg3: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn rb_call_super(arg1: ::libc::c_int, arg2: *const VALUE) -> VALUE;
    pub fn rb_current_receiver() -> VALUE;
    pub fn rb_get_kwargs(keyword_hash: VALUE, table: *const ID,
                         required: ::libc::c_int, optional: ::libc::c_int,
                         arg1: *mut VALUE) -> ::libc::c_int;
    pub fn rb_extract_keywords(orighash: *mut VALUE) -> VALUE;
    pub fn rb_gv_set(arg1: *const ::libc::c_char, arg2: VALUE) -> VALUE;
    pub fn rb_gv_get(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_iv_get(arg1: VALUE, arg2: *const ::libc::c_char) -> VALUE;
    pub fn rb_iv_set(arg1: VALUE, arg2: *const ::libc::c_char, arg3: VALUE)
     -> VALUE;
    pub fn rb_equal(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ruby_verbose_ptr() -> *mut VALUE;
    pub fn rb_ruby_debug_ptr() -> *mut VALUE;
    pub fn rb_raise(arg1: VALUE, arg2: *const ::libc::c_char, ...) -> ();
    pub fn rb_fatal(arg1: *const ::libc::c_char, ...) -> ();
    pub fn rb_bug(arg1: *const ::libc::c_char, ...) -> ();
    pub fn rb_bug_errno(arg1: *const ::libc::c_char, arg2: ::libc::c_int)
     -> ();
    pub fn rb_sys_fail(arg1: *const ::libc::c_char) -> ();
    pub fn rb_sys_fail_str(arg1: VALUE) -> ();
    pub fn rb_mod_sys_fail(arg1: VALUE, arg2: *const ::libc::c_char) -> ();
    pub fn rb_mod_sys_fail_str(arg1: VALUE, arg2: VALUE) -> ();
    pub fn rb_readwrite_sys_fail(arg1: ::libc::c_int,
                                 arg2: *const ::libc::c_char) -> ();
    pub fn rb_iter_break() -> ();
    pub fn rb_iter_break_value(arg1: VALUE) -> ();
    pub fn rb_exit(arg1: ::libc::c_int) -> ();
    pub fn rb_notimplement() -> ();
    pub fn rb_syserr_new(arg1: ::libc::c_int, arg2: *const ::libc::c_char)
     -> VALUE;
    pub fn rb_syserr_new_str(n: ::libc::c_int, arg: VALUE) -> VALUE;
    pub fn rb_syserr_fail(arg1: ::libc::c_int, arg2: *const ::libc::c_char)
     -> ();
    pub fn rb_syserr_fail_str(arg1: ::libc::c_int, arg2: VALUE) -> ();
    pub fn rb_mod_syserr_fail(arg1: VALUE, arg2: ::libc::c_int,
                              arg3: *const ::libc::c_char) -> ();
    pub fn rb_mod_syserr_fail_str(arg1: VALUE, arg2: ::libc::c_int,
                                  arg3: VALUE) -> ();
    pub fn rb_warning(arg1: *const ::libc::c_char, ...) -> ();
    pub fn rb_compile_warning(arg1: *const ::libc::c_char,
                              arg2: ::libc::c_int,
                              arg3: *const ::libc::c_char, ...) -> ();
    pub fn rb_sys_warning(arg1: *const ::libc::c_char, ...) -> ();
    pub fn rb_warn(arg1: *const ::libc::c_char, ...) -> ();
    pub fn rb_compile_warn(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                           arg3: *const ::libc::c_char, ...) -> ();
    pub fn rb_each(arg1: VALUE) -> VALUE;
    pub fn rb_yield(arg1: VALUE) -> VALUE;
    pub fn rb_yield_values(n: ::libc::c_int, ...) -> VALUE;
    pub fn rb_yield_values2(n: ::libc::c_int, argv: *const VALUE) -> VALUE;
    pub fn rb_yield_splat(arg1: VALUE) -> VALUE;
    pub fn rb_yield_block(arg1: VALUE, arg2: VALUE, arg3: ::libc::c_int,
                          arg4: *const VALUE, arg5: VALUE) -> VALUE;
    pub fn rb_block_given_p() -> ::libc::c_int;
    pub fn rb_need_block() -> ();
    pub fn rb_iterate(arg1:
                          ::std::option::Option<extern "C" fn(arg1: VALUE)
                                                    -> VALUE>, arg2: VALUE,
                      arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                      arg4: VALUE) -> VALUE;
    pub fn rb_block_call(arg1: VALUE, arg2: ID, arg3: ::libc::c_int,
                         arg4: *const VALUE, arg5: rb_block_call_func_t,
                         arg6: VALUE) -> VALUE;
    pub fn rb_rescue(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg2: VALUE,
                     arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg4: VALUE) -> VALUE;
    pub fn rb_rescue2(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                      arg2: VALUE,
                      arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                      arg4: VALUE, ...) -> VALUE;
    pub fn rb_ensure(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg2: VALUE,
                     arg3: ::std::option::Option<extern "C" fn() -> VALUE>,
                     arg4: VALUE) -> VALUE;
    pub fn rb_catch(arg1: *const ::libc::c_char,
                    arg2: ::std::option::Option<extern "C" fn() -> VALUE>,
                    arg3: VALUE) -> VALUE;
    pub fn rb_catch_obj(arg1: VALUE,
                        arg2: ::std::option::Option<extern "C" fn() -> VALUE>,
                        arg3: VALUE) -> VALUE;
    pub fn rb_throw(arg1: *const ::libc::c_char, arg2: VALUE) -> ();
    pub fn rb_throw_obj(arg1: VALUE, arg2: VALUE) -> ();
    pub fn rb_require(arg1: *const ::libc::c_char) -> VALUE;
    pub fn st_init_table(arg1: *const Struct_st_hash_type) -> *mut st_table;
    pub fn st_init_table_with_size(arg1: *const Struct_st_hash_type,
                                   arg2: st_index_t) -> *mut st_table;
    pub fn st_init_numtable() -> *mut st_table;
    pub fn st_init_numtable_with_size(arg1: st_index_t) -> *mut st_table;
    pub fn st_init_strtable() -> *mut st_table;
    pub fn st_init_strtable_with_size(arg1: st_index_t) -> *mut st_table;
    pub fn st_init_strcasetable() -> *mut st_table;
    pub fn st_init_strcasetable_with_size(arg1: st_index_t) -> *mut st_table;
    pub fn st_delete(arg1: *mut st_table, arg2: *mut st_data_t,
                     arg3: *mut st_data_t) -> ::libc::c_int;
    pub fn st_delete_safe(arg1: *mut st_table, arg2: *mut st_data_t,
                          arg3: *mut st_data_t, arg4: st_data_t)
     -> ::libc::c_int;
    pub fn st_shift(arg1: *mut st_table, arg2: *mut st_data_t,
                    arg3: *mut st_data_t) -> ::libc::c_int;
    pub fn st_insert(arg1: *mut st_table, arg2: st_data_t, arg3: st_data_t)
     -> ::libc::c_int;
    pub fn st_insert2(arg1: *mut st_table, arg2: st_data_t, arg3: st_data_t,
                      arg4:
                          ::std::option::Option<extern "C" fn(arg1: st_data_t)
                                                    -> st_data_t>)
     -> ::libc::c_int;
    pub fn st_lookup(arg1: *mut st_table, arg2: st_data_t,
                     arg3: *mut st_data_t) -> ::libc::c_int;
    pub fn st_get_key(arg1: *mut st_table, arg2: st_data_t,
                      arg3: *mut st_data_t) -> ::libc::c_int;
    pub fn st_update(table: *mut st_table, key: st_data_t,
                     func:
                         *mut ::std::option::Option<extern "C" fn()
                                                        -> ::libc::c_int>,
                     arg: st_data_t) -> ::libc::c_int;
    pub fn st_foreach(arg1: *mut st_table,
                      arg2:
                          ::std::option::Option<extern "C" fn()
                                                    -> ::libc::c_int>,
                      arg3: st_data_t) -> ::libc::c_int;
    pub fn st_foreach_check(arg1: *mut st_table,
                            arg2:
                                ::std::option::Option<extern "C" fn()
                                                          -> ::libc::c_int>,
                            arg3: st_data_t, arg4: st_data_t)
     -> ::libc::c_int;
    pub fn st_reverse_foreach(arg1: *mut st_table,
                              arg2:
                                  ::std::option::Option<extern "C" fn()
                                                            -> ::libc::c_int>,
                              arg3: st_data_t) -> ::libc::c_int;
    pub fn st_keys(table: *mut st_table, keys: *mut st_data_t,
                   size: st_index_t) -> st_index_t;
    pub fn st_keys_check(table: *mut st_table, keys: *mut st_data_t,
                         size: st_index_t, never: st_data_t) -> st_index_t;
    pub fn st_values(table: *mut st_table, values: *mut st_data_t,
                     size: st_index_t) -> st_index_t;
    pub fn st_values_check(table: *mut st_table, values: *mut st_data_t,
                           size: st_index_t, never: st_data_t) -> st_index_t;
    pub fn st_add_direct(arg1: *mut st_table, arg2: st_data_t,
                         arg3: st_data_t) -> ();
    pub fn st_free_table(arg1: *mut st_table) -> ();
    pub fn st_cleanup_safe(arg1: *mut st_table, arg2: st_data_t) -> ();
    pub fn st_clear(arg1: *mut st_table) -> ();
    pub fn st_copy(arg1: *mut st_table) -> *mut st_table;
    pub fn st_numcmp(arg1: st_data_t, arg2: st_data_t) -> ::libc::c_int;
    pub fn st_numhash(arg1: st_data_t) -> st_index_t;
    pub fn st_locale_insensitive_strcasecmp(s1: *const ::libc::c_char,
                                            s2: *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn st_locale_insensitive_strncasecmp(s1: *const ::libc::c_char,
                                             s2: *const ::libc::c_char,
                                             n: size_t) -> ::libc::c_int;
    pub fn st_memsize(arg1: *const st_table) -> size_t;
    pub fn st_hash(ptr: *const ::libc::c_void, len: size_t, h: st_index_t)
     -> st_index_t;
    pub fn st_hash_uint32(h: st_index_t, i: uint32_t) -> st_index_t;
    pub fn st_hash_uint(h: st_index_t, i: st_index_t) -> st_index_t;
    pub fn st_hash_end(h: st_index_t) -> st_index_t;
    pub fn st_hash_start(h: st_index_t) -> st_index_t;
    pub fn rb_mem_clear(arg1: *mut VALUE, arg2: ::libc::c_long) -> ();
    pub fn rb_assoc_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_check_array_type(arg1: VALUE) -> VALUE;
    pub fn rb_ary_new() -> VALUE;
    pub fn rb_ary_new_capa(capa: ::libc::c_long) -> VALUE;
    pub fn rb_ary_new_from_args(n: ::libc::c_long, ...) -> VALUE;
    pub fn rb_ary_new_from_values(n: ::libc::c_long, elts: *const VALUE)
     -> VALUE;
    pub fn rb_ary_tmp_new(arg1: ::libc::c_long) -> VALUE;
    pub fn rb_ary_free(arg1: VALUE) -> ();
    pub fn rb_ary_modify(arg1: VALUE) -> ();
    pub fn rb_ary_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_ary_shared_with_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_aref(arg1: ::libc::c_int, arg2: *const VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_ary_subseq(arg1: VALUE, arg2: ::libc::c_long,
                         arg3: ::libc::c_long) -> VALUE;
    pub fn rb_ary_store(arg1: VALUE, arg2: ::libc::c_long, arg3: VALUE) -> ();
    pub fn rb_ary_dup(arg1: VALUE) -> VALUE;
    pub fn rb_ary_resurrect(ary: VALUE) -> VALUE;
    pub fn rb_ary_to_ary(arg1: VALUE) -> VALUE;
    pub fn rb_ary_to_s(arg1: VALUE) -> VALUE;
    pub fn rb_ary_cat(arg1: VALUE, arg2: *const VALUE, arg3: ::libc::c_long)
     -> VALUE;
    pub fn rb_ary_push(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_pop(arg1: VALUE) -> VALUE;
    pub fn rb_ary_shift(arg1: VALUE) -> VALUE;
    pub fn rb_ary_unshift(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_entry(arg1: VALUE, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_ary_each(arg1: VALUE) -> VALUE;
    pub fn rb_ary_join(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_reverse(arg1: VALUE) -> VALUE;
    pub fn rb_ary_rotate(arg1: VALUE, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_ary_sort(arg1: VALUE) -> VALUE;
    pub fn rb_ary_sort_bang(arg1: VALUE) -> VALUE;
    pub fn rb_ary_delete(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_delete_at(arg1: VALUE, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_ary_clear(arg1: VALUE) -> VALUE;
    pub fn rb_ary_plus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_concat(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_assoc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_rassoc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_includes(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_cmp(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_ary_replace(copy: VALUE, orig: VALUE) -> VALUE;
    pub fn rb_get_values_at(arg1: VALUE, arg2: ::libc::c_long,
                            arg3: ::libc::c_int, arg4: *const VALUE,
                            arg5:
                                ::std::option::Option<extern "C" fn(arg1:
                                                                        VALUE,
                                                                    arg2:
                                                                        ::libc::c_long)
                                                          -> VALUE>) -> VALUE;
    pub fn rb_ary_resize(ary: VALUE, len: ::libc::c_long) -> VALUE;
    pub fn rb_big_new(arg1: size_t, arg2: ::libc::c_int) -> VALUE;
    pub fn rb_bigzero_p(x: VALUE) -> ::libc::c_int;
    pub fn rb_big_clone(arg1: VALUE) -> VALUE;
    pub fn rb_big_2comp(arg1: VALUE) -> ();
    pub fn rb_big_norm(arg1: VALUE) -> VALUE;
    pub fn rb_big_resize(big: VALUE, len: size_t) -> ();
    pub fn rb_cstr_to_inum(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                           arg3: ::libc::c_int) -> VALUE;
    pub fn rb_str_to_inum(arg1: VALUE, arg2: ::libc::c_int,
                          arg3: ::libc::c_int) -> VALUE;
    pub fn rb_cstr2inum(arg1: *const ::libc::c_char, arg2: ::libc::c_int)
     -> VALUE;
    pub fn rb_str2inum(arg1: VALUE, arg2: ::libc::c_int) -> VALUE;
    pub fn rb_big2str(arg1: VALUE, arg2: ::libc::c_int) -> VALUE;
    pub fn rb_big2long(arg1: VALUE) -> ::libc::c_long;
    pub fn rb_big2ulong(arg1: VALUE) -> ::libc::c_ulong;
    pub fn rb_big2ll(arg1: VALUE) -> ::libc::c_longlong;
    pub fn rb_big2ull(arg1: VALUE) -> ::libc::c_ulonglong;
    pub fn rb_big_pack(val: VALUE, buf: *mut ::libc::c_ulong,
                       num_longs: ::libc::c_long) -> ();
    pub fn rb_big_unpack(buf: *mut ::libc::c_ulong, num_longs: ::libc::c_long)
     -> VALUE;
    pub fn rb_uv_to_utf8(arg1: *mut ::libc::c_char, arg2: ::libc::c_ulong)
     -> ::libc::c_int;
    pub fn rb_dbl2big(arg1: ::libc::c_double) -> VALUE;
    pub fn rb_big2dbl(arg1: VALUE) -> ::libc::c_double;
    pub fn rb_big_cmp(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_eq(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_eql(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_plus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_minus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_mul(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_div(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_idiv(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_modulo(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_divmod(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_pow(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_and(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_or(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_xor(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_lshift(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_big_rshift(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_integer_pack(val: VALUE, words: *mut ::libc::c_void,
                           numwords: size_t, wordsize: size_t, nails: size_t,
                           flags: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_integer_unpack(words: *const ::libc::c_void, numwords: size_t,
                             wordsize: size_t, nails: size_t,
                             flags: ::libc::c_int) -> VALUE;
    pub fn rb_absint_size(val: VALUE, nlz_bits_ret: *mut ::libc::c_int)
     -> size_t;
    pub fn rb_absint_numwords(val: VALUE, word_numbits: size_t,
                              nlz_bits_ret: *mut size_t) -> size_t;
    pub fn rb_absint_singlebit_p(val: VALUE) -> ::libc::c_int;
    pub fn rb_rational_raw(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_rational_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_Rational(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_rational_num(rat: VALUE) -> VALUE;
    pub fn rb_rational_den(rat: VALUE) -> VALUE;
    pub fn rb_flt_rationalize_with_prec(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_flt_rationalize(arg1: VALUE) -> VALUE;
    pub fn rb_complex_raw(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_complex_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_complex_polar(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_Complex(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_complex_set_real(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_complex_set_imag(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_class_boot(arg1: VALUE) -> VALUE;
    pub fn rb_class_new(arg1: VALUE) -> VALUE;
    pub fn rb_mod_init_copy(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_singleton_class_clone(arg1: VALUE) -> VALUE;
    pub fn rb_singleton_class_attached(arg1: VALUE, arg2: VALUE) -> ();
    pub fn rb_make_metaclass(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_check_inheritable(arg1: VALUE) -> ();
    pub fn rb_class_inherited(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_define_class_id(arg1: ID, arg2: VALUE) -> VALUE;
    pub fn rb_define_class_id_under(arg1: VALUE, arg2: ID, arg3: VALUE)
     -> VALUE;
    pub fn rb_module_new() -> VALUE;
    pub fn rb_define_module_id(arg1: ID) -> VALUE;
    pub fn rb_define_module_id_under(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_include_class_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_mod_included_modules(arg1: VALUE) -> VALUE;
    pub fn rb_mod_include_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_mod_ancestors(arg1: VALUE) -> VALUE;
    pub fn rb_class_instance_methods(arg1: ::libc::c_int, arg2: *const VALUE,
                                     arg3: VALUE) -> VALUE;
    pub fn rb_class_public_instance_methods(arg1: ::libc::c_int,
                                            arg2: *const VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_class_protected_instance_methods(arg1: ::libc::c_int,
                                               arg2: *const VALUE,
                                               arg3: VALUE) -> VALUE;
    pub fn rb_class_private_instance_methods(arg1: ::libc::c_int,
                                             arg2: *const VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_obj_singleton_methods(arg1: ::libc::c_int, arg2: *const VALUE,
                                    arg3: VALUE) -> VALUE;
    pub fn rb_define_method_id(arg1: VALUE, arg2: ID,
                               arg3:
                                   ::std::option::Option<extern "C" fn()
                                                             -> VALUE>,
                               arg4: ::libc::c_int) -> ();
    pub fn rb_frozen_class_p(arg1: VALUE) -> ();
    pub fn rb_undef(arg1: VALUE, arg2: ID) -> ();
    pub fn rb_define_protected_method(arg1: VALUE,
                                      arg2: *const ::libc::c_char,
                                      arg3:
                                          ::std::option::Option<extern "C" fn()
                                                                    -> VALUE>,
                                      arg4: ::libc::c_int) -> ();
    pub fn rb_define_private_method(arg1: VALUE, arg2: *const ::libc::c_char,
                                    arg3:
                                        ::std::option::Option<extern "C" fn()
                                                                  -> VALUE>,
                                    arg4: ::libc::c_int) -> ();
    pub fn rb_define_singleton_method(arg1: VALUE,
                                      arg2: *const ::libc::c_char,
                                      arg3:
                                          ::std::option::Option<extern "C" fn()
                                                                    -> VALUE>,
                                      arg4: ::libc::c_int) -> ();
    pub fn rb_singleton_class(arg1: VALUE) -> VALUE;
    pub fn rb_cmpint(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> ::libc::c_int;
    pub fn rb_cmperr(arg1: VALUE, arg2: VALUE) -> ();
    pub fn rb_fiber_new(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                        arg2: VALUE) -> VALUE;
    pub fn rb_fiber_resume(fib: VALUE, argc: ::libc::c_int,
                           argv: *const VALUE) -> VALUE;
    pub fn rb_fiber_yield(argc: ::libc::c_int, argv: *const VALUE) -> VALUE;
    pub fn rb_fiber_current() -> VALUE;
    pub fn rb_fiber_alive_p(arg1: VALUE) -> VALUE;
    pub fn rb_enum_values_pack(arg1: ::libc::c_int, arg2: *const VALUE)
     -> VALUE;
    pub fn rb_enumeratorize(arg1: VALUE, arg2: VALUE, arg3: ::libc::c_int,
                            arg4: *const VALUE) -> VALUE;
    pub fn rb_enumeratorize_with_size(arg1: VALUE, arg2: VALUE,
                                      arg3: ::libc::c_int, arg4: *const VALUE,
                                      arg5:
                                          *mut ::std::option::Option<extern "C" fn()
                                                                         ->
                                                                             VALUE>)
     -> VALUE;
    pub fn rb_exc_new(arg1: VALUE, arg2: *const ::libc::c_char,
                      arg3: ::libc::c_long) -> VALUE;
    pub fn rb_exc_new_cstr(arg1: VALUE, arg2: *const ::libc::c_char) -> VALUE;
    pub fn rb_exc_new_str(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_loaderror(arg1: *const ::libc::c_char, ...) -> ();
    pub fn rb_loaderror_with_path(path: VALUE,
                                  arg1: *const ::libc::c_char, ...) -> ();
    pub fn rb_name_error(arg1: ID, arg2: *const ::libc::c_char, ...) -> ();
    pub fn rb_name_error_str(arg1: VALUE, arg2: *const ::libc::c_char, ...)
     -> ();
    pub fn rb_invalid_str(arg1: *const ::libc::c_char,
                          arg2: *const ::libc::c_char) -> ();
    pub fn rb_compile_error(arg1: *const ::libc::c_char, arg2: ::libc::c_int,
                            arg3: *const ::libc::c_char, ...) -> ();
    pub fn rb_compile_error_with_enc(arg1: *const ::libc::c_char,
                                     arg2: ::libc::c_int,
                                     arg3: *mut ::libc::c_void,
                                     arg4: *const ::libc::c_char, ...) -> ();
    pub fn rb_compile_error_append(arg1: *const ::libc::c_char, ...) -> ();
    pub fn rb_error_frozen(arg1: *const ::libc::c_char) -> ();
    pub fn rb_error_frozen_object(arg1: VALUE) -> ();
    pub fn rb_error_untrusted(arg1: VALUE) -> ();
    pub fn rb_check_frozen(arg1: VALUE) -> ();
    pub fn rb_check_trusted(arg1: VALUE) -> ();
    pub fn rb_check_copyable(obj: VALUE, orig: VALUE) -> ();
    pub fn rb_sourceline() -> ::libc::c_int;
    pub fn rb_sourcefile() -> *const ::libc::c_char;
    pub fn rb_check_funcall(arg1: VALUE, arg2: ID, arg3: ::libc::c_int,
                            arg4: *const VALUE) -> VALUE;
    pub fn rb_error_arity(arg1: ::libc::c_int, arg2: ::libc::c_int,
                          arg3: ::libc::c_int) -> ();
    pub fn rb_fd_init(arg1: *mut rb_fdset_t) -> ();
    pub fn rb_fd_term(arg1: *mut rb_fdset_t) -> ();
    pub fn rb_fd_zero(arg1: *mut rb_fdset_t) -> ();
    pub fn rb_fd_set(arg1: ::libc::c_int, arg2: *mut rb_fdset_t) -> ();
    pub fn rb_fd_clr(arg1: ::libc::c_int, arg2: *mut rb_fdset_t) -> ();
    pub fn rb_fd_isset(arg1: ::libc::c_int, arg2: *const rb_fdset_t)
     -> ::libc::c_int;
    pub fn rb_fd_copy(arg1: *mut rb_fdset_t, arg2: *const fd_set,
                      arg3: ::libc::c_int) -> ();
    pub fn rb_fd_dup(dst: *mut rb_fdset_t, src: *const rb_fdset_t) -> ();
    pub fn rb_fd_select(arg1: ::libc::c_int, arg2: *mut rb_fdset_t,
                        arg3: *mut rb_fdset_t, arg4: *mut rb_fdset_t,
                        arg5: *mut Struct_timeval) -> ::libc::c_int;
    pub fn rb_exc_raise(arg1: VALUE) -> ();
    pub fn rb_exc_fatal(arg1: VALUE) -> ();
    pub fn rb_f_exit(arg1: ::libc::c_int, arg2: *const VALUE) -> VALUE;
    pub fn rb_f_abort(arg1: ::libc::c_int, arg2: *const VALUE) -> VALUE;
    pub fn rb_remove_method(arg1: VALUE, arg2: *const ::libc::c_char) -> ();
    pub fn rb_remove_method_id(arg1: VALUE, arg2: ID) -> ();
    pub fn rb_define_alloc_func(arg1: VALUE, arg2: rb_alloc_func_t) -> ();
    pub fn rb_undef_alloc_func(arg1: VALUE) -> ();
    pub fn rb_get_alloc_func(arg1: VALUE) -> rb_alloc_func_t;
    pub fn rb_clear_cache() -> ();
    pub fn rb_clear_constant_cache() -> ();
    pub fn rb_clear_method_cache_by_class(arg1: VALUE) -> ();
    pub fn rb_alias(arg1: VALUE, arg2: ID, arg3: ID) -> ();
    pub fn rb_attr(arg1: VALUE, arg2: ID, arg3: ::libc::c_int,
                   arg4: ::libc::c_int, arg5: ::libc::c_int) -> ();
    pub fn rb_method_boundp(arg1: VALUE, arg2: ID, arg3: ::libc::c_int)
     -> ::libc::c_int;
    pub fn rb_method_basic_definition_p(arg1: VALUE, arg2: ID)
     -> ::libc::c_int;
    pub fn rb_eval_cmd(arg1: VALUE, arg2: VALUE, arg3: ::libc::c_int)
     -> VALUE;
    pub fn rb_obj_respond_to(arg1: VALUE, arg2: ID, arg3: ::libc::c_int)
     -> ::libc::c_int;
    pub fn rb_respond_to(arg1: VALUE, arg2: ID) -> ::libc::c_int;
    pub fn rb_f_notimplement(argc: ::libc::c_int, argv: *const VALUE,
                             obj: VALUE) -> VALUE;
    pub fn rb_interrupt() -> ();
    pub fn rb_apply(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
    pub fn rb_backtrace() -> ();
    pub fn rb_frame_this_func() -> ID;
    pub fn rb_obj_instance_eval(arg1: ::libc::c_int, arg2: *const VALUE,
                                arg3: VALUE) -> VALUE;
    pub fn rb_obj_instance_exec(arg1: ::libc::c_int, arg2: *const VALUE,
                                arg3: VALUE) -> VALUE;
    pub fn rb_mod_module_eval(arg1: ::libc::c_int, arg2: *const VALUE,
                              arg3: VALUE) -> VALUE;
    pub fn rb_mod_module_exec(arg1: ::libc::c_int, arg2: *const VALUE,
                              arg3: VALUE) -> VALUE;
    pub fn rb_load(arg1: VALUE, arg2: ::libc::c_int) -> ();
    pub fn rb_load_protect(arg1: VALUE, arg2: ::libc::c_int,
                           arg3: *mut ::libc::c_int) -> ();
    pub fn rb_jump_tag(arg1: ::libc::c_int) -> ();
    pub fn rb_provided(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn rb_feature_provided(arg1: *const ::libc::c_char,
                               arg2: *mut *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn rb_provide(arg1: *const ::libc::c_char) -> ();
    pub fn rb_f_require(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_require_safe(arg1: VALUE, arg2: ::libc::c_int) -> VALUE;
    pub fn rb_obj_call_init(arg1: VALUE, arg2: ::libc::c_int,
                            arg3: *const VALUE) -> ();
    pub fn rb_class_new_instance(arg1: ::libc::c_int, arg2: *const VALUE,
                                 arg3: VALUE) -> VALUE;
    pub fn rb_block_proc() -> VALUE;
    pub fn rb_block_lambda() -> VALUE;
    pub fn rb_proc_new(arg1: ::std::option::Option<extern "C" fn() -> VALUE>,
                       arg2: VALUE) -> VALUE;
    pub fn rb_obj_is_proc(arg1: VALUE) -> VALUE;
    pub fn rb_proc_call(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_proc_call_with_block(arg1: VALUE, argc: ::libc::c_int,
                                   argv: *const VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_proc_arity(arg1: VALUE) -> ::libc::c_int;
    pub fn rb_proc_lambda_p(arg1: VALUE) -> VALUE;
    pub fn rb_binding_new() -> VALUE;
    pub fn rb_obj_method(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_is_method(arg1: VALUE) -> VALUE;
    pub fn rb_method_call(arg1: ::libc::c_int, arg2: *const VALUE,
                          arg3: VALUE) -> VALUE;
    pub fn rb_method_call_with_block(arg1: ::libc::c_int, arg2: *const VALUE,
                                     arg3: VALUE, arg4: VALUE) -> VALUE;
    pub fn rb_mod_method_arity(arg1: VALUE, arg2: ID) -> ::libc::c_int;
    pub fn rb_obj_method_arity(arg1: VALUE, arg2: ID) -> ::libc::c_int;
    pub fn rb_protect(arg1:
                          ::std::option::Option<extern "C" fn(arg1: VALUE)
                                                    -> VALUE>, arg2: VALUE,
                      arg3: *mut ::libc::c_int) -> VALUE;
    pub fn rb_set_end_proc(arg1:
                               ::std::option::Option<extern "C" fn(arg1:
                                                                       VALUE)
                                                         -> ()>, arg2: VALUE)
     -> ();
    pub fn rb_exec_end_proc() -> ();
    pub fn rb_thread_schedule() -> ();
    pub fn rb_thread_wait_fd(arg1: ::libc::c_int) -> ();
    pub fn rb_thread_fd_writable(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_thread_fd_close(arg1: ::libc::c_int) -> ();
    pub fn rb_thread_alone() -> ::libc::c_int;
    pub fn rb_thread_sleep(arg1: ::libc::c_int) -> ();
    pub fn rb_thread_sleep_forever() -> ();
    pub fn rb_thread_sleep_deadly() -> ();
    pub fn rb_thread_stop() -> VALUE;
    pub fn rb_thread_wakeup(arg1: VALUE) -> VALUE;
    pub fn rb_thread_wakeup_alive(arg1: VALUE) -> VALUE;
    pub fn rb_thread_run(arg1: VALUE) -> VALUE;
    pub fn rb_thread_kill(arg1: VALUE) -> VALUE;
    pub fn rb_thread_create(arg1:
                                ::std::option::Option<extern "C" fn()
                                                          -> VALUE>,
                            arg2: *mut ::libc::c_void) -> VALUE;
    pub fn rb_thread_fd_select(arg1: ::libc::c_int, arg2: *mut rb_fdset_t,
                               arg3: *mut rb_fdset_t, arg4: *mut rb_fdset_t,
                               arg5: *mut Struct_timeval) -> ::libc::c_int;
    pub fn rb_thread_wait_for(arg1: Struct_timeval) -> ();
    pub fn rb_thread_current() -> VALUE;
    pub fn rb_thread_main() -> VALUE;
    pub fn rb_thread_local_aref(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_thread_local_aset(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
    pub fn rb_thread_atfork() -> ();
    pub fn rb_thread_atfork_before_exec() -> ();
    pub fn rb_exec_recursive(arg1:
                                 ::std::option::Option<extern "C" fn(arg1:
                                                                         VALUE,
                                                                     arg2:
                                                                         VALUE,
                                                                     arg3:
                                                                         ::libc::c_int)
                                                           -> VALUE>,
                             arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_exec_recursive_paired(arg1:
                                        ::std::option::Option<extern "C" fn(arg1:
                                                                                VALUE,
                                                                            arg2:
                                                                                VALUE,
                                                                            arg3:
                                                                                ::libc::c_int)
                                                                  -> VALUE>,
                                    arg2: VALUE, arg3: VALUE, arg4: VALUE)
     -> VALUE;
    pub fn rb_exec_recursive_outer(arg1:
                                       ::std::option::Option<extern "C" fn(arg1:
                                                                               VALUE,
                                                                           arg2:
                                                                               VALUE,
                                                                           arg3:
                                                                               ::libc::c_int)
                                                                 -> VALUE>,
                                   arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_exec_recursive_paired_outer(arg1:
                                              ::std::option::Option<extern "C" fn(arg1:
                                                                                      VALUE,
                                                                                  arg2:
                                                                                      VALUE,
                                                                                  arg3:
                                                                                      ::libc::c_int)
                                                                        ->
                                                                            VALUE>,
                                          arg2: VALUE, arg3: VALUE,
                                          arg4: VALUE) -> VALUE;
    pub fn rb_dir_getwd() -> VALUE;
    pub fn rb_file_s_expand_path(arg1: ::libc::c_int, arg2: *const VALUE)
     -> VALUE;
    pub fn rb_file_expand_path(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_file_s_absolute_path(arg1: ::libc::c_int, arg2: *const VALUE)
     -> VALUE;
    pub fn rb_file_absolute_path(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_file_dirname(fname: VALUE) -> VALUE;
    pub fn rb_find_file_ext_safe(arg1: *mut VALUE,
                                 arg2: *const *const ::libc::c_char,
                                 arg3: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_find_file_safe(arg1: VALUE, arg2: ::libc::c_int) -> VALUE;
    pub fn rb_find_file_ext(arg1: *mut VALUE,
                            arg2: *const *const ::libc::c_char)
     -> ::libc::c_int;
    pub fn rb_find_file(arg1: VALUE) -> VALUE;
    pub fn rb_file_directory_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_encode_ospath(arg1: VALUE) -> VALUE;
    pub fn rb_is_absolute_path(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn rb_memerror() -> ();
    pub fn rb_during_gc() -> ::libc::c_int;
    pub fn rb_gc_mark_locations(arg1: *const VALUE, arg2: *const VALUE) -> ();
    pub fn rb_mark_tbl(arg1: *mut Struct_st_table) -> ();
    pub fn rb_mark_set(arg1: *mut Struct_st_table) -> ();
    pub fn rb_mark_hash(arg1: *mut Struct_st_table) -> ();
    pub fn rb_gc_mark_maybe(arg1: VALUE) -> ();
    pub fn rb_gc_mark(arg1: VALUE) -> ();
    pub fn rb_gc_force_recycle(arg1: VALUE) -> ();
    pub fn rb_gc() -> ();
    pub fn rb_gc_copy_finalizer(arg1: VALUE, arg2: VALUE) -> ();
    pub fn rb_gc_finalize_deferred() -> ();
    pub fn rb_gc_call_finalizer_at_exit() -> ();
    pub fn rb_gc_enable() -> VALUE;
    pub fn rb_gc_disable() -> VALUE;
    pub fn rb_gc_start() -> VALUE;
    pub fn rb_define_finalizer(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_undefine_finalizer(arg1: VALUE) -> VALUE;
    pub fn rb_gc_count() -> size_t;
    pub fn rb_gc_stat(arg1: VALUE) -> size_t;
    pub fn rb_gc_latest_gc_info(arg1: VALUE) -> VALUE;
    pub fn st_foreach_safe(arg1: *mut Struct_st_table,
                           arg2:
                               ::std::option::Option<extern "C" fn()
                                                         -> ::libc::c_int>,
                           arg3: st_data_t) -> ();
    pub fn rb_check_hash_type(arg1: VALUE) -> VALUE;
    pub fn rb_hash_foreach(arg1: VALUE,
                           arg2:
                               ::std::option::Option<extern "C" fn()
                                                         -> ::libc::c_int>,
                           arg3: VALUE) -> ();
    pub fn rb_hash(arg1: VALUE) -> VALUE;
    pub fn rb_hash_new() -> VALUE;
    pub fn rb_hash_dup(arg1: VALUE) -> VALUE;
    pub fn rb_hash_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_hash_aref(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_lookup(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_lookup2(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_hash_fetch(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_aset(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_hash_clear(arg1: VALUE) -> VALUE;
    pub fn rb_hash_delete_if(arg1: VALUE) -> VALUE;
    pub fn rb_hash_delete(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_hash_set_ifnone(hash: VALUE, ifnone: VALUE) -> VALUE;
    pub fn rb_hash_update_by(hash1: VALUE, hash2: VALUE,
                             func:
                                 *mut ::std::option::Option<extern "C" fn()
                                                                -> VALUE>)
     -> VALUE;
    pub fn rb_hash_tbl(arg1: VALUE) -> *mut Struct_st_table;
    pub fn rb_path_check(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn rb_env_path_tainted() -> ::libc::c_int;
    pub fn rb_env_clear() -> VALUE;
    pub fn rb_hash_size(arg1: VALUE) -> VALUE;
    pub fn rb_hash_iter_lev(arg1: VALUE) -> ::libc::c_int;
    pub fn rb_hash_ifnone(arg1: VALUE) -> VALUE;
    pub fn rb_io_write(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_gets(arg1: VALUE) -> VALUE;
    pub fn rb_io_getbyte(arg1: VALUE) -> VALUE;
    pub fn rb_io_ungetc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_ungetbyte(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_close(arg1: VALUE) -> VALUE;
    pub fn rb_io_flush(arg1: VALUE) -> VALUE;
    pub fn rb_io_eof(arg1: VALUE) -> VALUE;
    pub fn rb_io_binmode(arg1: VALUE) -> VALUE;
    pub fn rb_io_ascii8bit_binmode(arg1: VALUE) -> VALUE;
    pub fn rb_io_addstr(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_io_printf(arg1: ::libc::c_int, arg2: *const VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_io_print(arg1: ::libc::c_int, arg2: *const VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_io_puts(arg1: ::libc::c_int, arg2: *const VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_io_fdopen(arg1: ::libc::c_int, arg2: ::libc::c_int,
                        arg3: *const ::libc::c_char) -> VALUE;
    pub fn rb_io_get_io(arg1: VALUE) -> VALUE;
    pub fn rb_file_open(arg1: *const ::libc::c_char,
                        arg2: *const ::libc::c_char) -> VALUE;
    pub fn rb_file_open_str(arg1: VALUE, arg2: *const ::libc::c_char)
     -> VALUE;
    pub fn rb_gets() -> VALUE;
    pub fn rb_write_error(arg1: *const ::libc::c_char) -> ();
    pub fn rb_write_error2(arg1: *const ::libc::c_char, arg2: ::libc::c_long)
     -> ();
    pub fn rb_close_before_exec(lowfd: ::libc::c_int, maxhint: ::libc::c_int,
                                noclose_fds: VALUE) -> ();
    pub fn rb_pipe(pipes: *mut ::libc::c_int) -> ::libc::c_int;
    pub fn rb_reserved_fd_p(fd: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_cloexec_open(pathname: *const ::libc::c_char,
                           flags: ::libc::c_int, mode: mode_t)
     -> ::libc::c_int;
    pub fn rb_cloexec_dup(oldfd: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_cloexec_dup2(oldfd: ::libc::c_int, newfd: ::libc::c_int)
     -> ::libc::c_int;
    pub fn rb_cloexec_pipe(fildes: *mut ::libc::c_int) -> ::libc::c_int;
    pub fn rb_cloexec_fcntl_dupfd(fd: ::libc::c_int, minfd: ::libc::c_int)
     -> ::libc::c_int;
    pub fn rb_update_max_fd(fd: ::libc::c_int) -> ();
    pub fn rb_fd_fix_cloexec(fd: ::libc::c_int) -> ();
    pub fn rb_marshal_dump(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_marshal_load(arg1: VALUE) -> VALUE;
    pub fn rb_marshal_define_compat(newclass: VALUE, oldclass: VALUE,
                                    dumper:
                                        ::std::option::Option<extern "C" fn(arg1:
                                                                                VALUE)
                                                                  -> VALUE>,
                                    loader:
                                        ::std::option::Option<extern "C" fn(arg1:
                                                                                VALUE,
                                                                            arg2:
                                                                                VALUE)
                                                                  -> VALUE>)
     -> ();
    pub fn rb_num_zerodiv() -> ();
    pub fn rb_num_coerce_bin(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num_coerce_cmp(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num_coerce_relop(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num_coerce_bit(arg1: VALUE, arg2: VALUE, arg3: ID) -> VALUE;
    pub fn rb_num2fix(arg1: VALUE) -> VALUE;
    pub fn rb_fix2str(arg1: VALUE, arg2: ::libc::c_int) -> VALUE;
    pub fn rb_dbl_cmp(arg1: ::libc::c_double, arg2: ::libc::c_double)
     -> VALUE;
    pub fn rb_eql(arg1: VALUE, arg2: VALUE) -> ::libc::c_int;
    pub fn rb_any_to_s(arg1: VALUE) -> VALUE;
    pub fn rb_inspect(arg1: VALUE) -> VALUE;
    pub fn rb_obj_is_instance_of(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_is_kind_of(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_alloc(arg1: VALUE) -> VALUE;
    pub fn rb_obj_clone(arg1: VALUE) -> VALUE;
    pub fn rb_obj_dup(arg1: VALUE) -> VALUE;
    pub fn rb_obj_init_copy(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_obj_taint(arg1: VALUE) -> VALUE;
    pub fn rb_obj_tainted(arg1: VALUE) -> VALUE;
    pub fn rb_obj_untaint(arg1: VALUE) -> VALUE;
    pub fn rb_obj_untrust(arg1: VALUE) -> VALUE;
    pub fn rb_obj_untrusted(arg1: VALUE) -> VALUE;
    pub fn rb_obj_trust(arg1: VALUE) -> VALUE;
    pub fn rb_obj_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_obj_frozen_p(arg1: VALUE) -> VALUE;
    pub fn rb_obj_id(arg1: VALUE) -> VALUE;
    pub fn rb_obj_class(arg1: VALUE) -> VALUE;
    pub fn rb_class_real(arg1: VALUE) -> VALUE;
    pub fn rb_class_inherited_p(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_class_superclass(arg1: VALUE) -> VALUE;
    pub fn rb_class_get_superclass(arg1: VALUE) -> VALUE;
    pub fn rb_convert_type(arg1: VALUE, arg2: ::libc::c_int,
                           arg3: *const ::libc::c_char,
                           arg4: *const ::libc::c_char) -> VALUE;
    pub fn rb_check_convert_type(arg1: VALUE, arg2: ::libc::c_int,
                                 arg3: *const ::libc::c_char,
                                 arg4: *const ::libc::c_char) -> VALUE;
    pub fn rb_check_to_integer(arg1: VALUE, arg2: *const ::libc::c_char)
     -> VALUE;
    pub fn rb_check_to_float(arg1: VALUE) -> VALUE;
    pub fn rb_to_int(arg1: VALUE) -> VALUE;
    pub fn rb_check_to_int(arg1: VALUE) -> VALUE;
    pub fn rb_Integer(arg1: VALUE) -> VALUE;
    pub fn rb_to_float(arg1: VALUE) -> VALUE;
    pub fn rb_Float(arg1: VALUE) -> VALUE;
    pub fn rb_String(arg1: VALUE) -> VALUE;
    pub fn rb_Array(arg1: VALUE) -> VALUE;
    pub fn rb_Hash(arg1: VALUE) -> VALUE;
    pub fn rb_cstr_to_dbl(arg1: *const ::libc::c_char, arg2: ::libc::c_int)
     -> ::libc::c_double;
    pub fn rb_str_to_dbl(arg1: VALUE, arg2: ::libc::c_int)
     -> ::libc::c_double;
    pub fn rb_id_attrset(arg1: ID) -> ID;
    pub fn rb_is_const_id(arg1: ID) -> ::libc::c_int;
    pub fn rb_is_global_id(arg1: ID) -> ::libc::c_int;
    pub fn rb_is_instance_id(arg1: ID) -> ::libc::c_int;
    pub fn rb_is_attrset_id(arg1: ID) -> ::libc::c_int;
    pub fn rb_is_class_id(arg1: ID) -> ::libc::c_int;
    pub fn rb_is_local_id(arg1: ID) -> ::libc::c_int;
    pub fn rb_is_junk_id(arg1: ID) -> ::libc::c_int;
    pub fn rb_symname_p(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn rb_sym_interned_p(arg1: VALUE) -> ::libc::c_int;
    pub fn rb_backref_get() -> VALUE;
    pub fn rb_backref_set(arg1: VALUE) -> ();
    pub fn rb_lastline_get() -> VALUE;
    pub fn rb_lastline_set(arg1: VALUE) -> ();
    pub fn rb_sym_all_symbols() -> VALUE;
    pub fn rb_last_status_set(status: ::libc::c_int, pid: pid_t) -> ();
    pub fn rb_last_status_get() -> VALUE;
    pub fn rb_proc_exec(arg1: *const ::libc::c_char) -> ::libc::c_int;
    pub fn rb_f_exec(arg1: ::libc::c_int, arg2: *const VALUE) -> VALUE;
    pub fn rb_waitpid(pid: pid_t, status: *mut ::libc::c_int,
                      flags: ::libc::c_int) -> pid_t;
    pub fn rb_syswait(pid: pid_t) -> ();
    pub fn rb_spawn(arg1: ::libc::c_int, arg2: *const VALUE) -> pid_t;
    pub fn rb_spawn_err(arg1: ::libc::c_int, arg2: *const VALUE,
                        arg3: *mut ::libc::c_char, arg4: size_t) -> pid_t;
    pub fn rb_proc_times(arg1: VALUE) -> VALUE;
    pub fn rb_detach_process(pid: pid_t) -> VALUE;
    pub fn rb_range_new(arg1: VALUE, arg2: VALUE, arg3: ::libc::c_int)
     -> VALUE;
    pub fn rb_range_beg_len(arg1: VALUE, arg2: *mut ::libc::c_long,
                            arg3: *mut ::libc::c_long, arg4: ::libc::c_long,
                            arg5: ::libc::c_int) -> VALUE;
    pub fn rb_range_values(range: VALUE, begp: *mut VALUE, endp: *mut VALUE,
                           exclp: *mut ::libc::c_int) -> ::libc::c_int;
    pub fn rb_genrand_int32() -> ::libc::c_uint;
    pub fn rb_genrand_real() -> ::libc::c_double;
    pub fn rb_reset_random_seed() -> ();
    pub fn rb_random_bytes(rnd: VALUE, n: ::libc::c_long) -> VALUE;
    pub fn rb_random_int(rnd: VALUE, max: VALUE) -> VALUE;
    pub fn rb_random_int32(rnd: VALUE) -> ::libc::c_uint;
    pub fn rb_random_real(rnd: VALUE) -> ::libc::c_double;
    pub fn rb_random_ulong_limited(rnd: VALUE, limit: ::libc::c_ulong)
     -> ::libc::c_ulong;
    pub fn rb_genrand_ulong_limited(i: ::libc::c_ulong) -> ::libc::c_ulong;
    pub fn rb_memcicmp(arg1: *const ::libc::c_void,
                       arg2: *const ::libc::c_void, arg3: ::libc::c_long)
     -> ::libc::c_int;
    pub fn rb_match_busy(arg1: VALUE) -> ();
    pub fn rb_reg_nth_defined(arg1: ::libc::c_int, arg2: VALUE) -> VALUE;
    pub fn rb_reg_nth_match(arg1: ::libc::c_int, arg2: VALUE) -> VALUE;
    pub fn rb_reg_backref_number(_match: VALUE, backref: VALUE)
     -> ::libc::c_int;
    pub fn rb_reg_last_match(arg1: VALUE) -> VALUE;
    pub fn rb_reg_match_pre(arg1: VALUE) -> VALUE;
    pub fn rb_reg_match_post(arg1: VALUE) -> VALUE;
    pub fn rb_reg_match_last(arg1: VALUE) -> VALUE;
    pub fn rb_reg_new_str(arg1: VALUE, arg2: ::libc::c_int) -> VALUE;
    pub fn rb_reg_new(arg1: *const ::libc::c_char, arg2: ::libc::c_long,
                      arg3: ::libc::c_int) -> VALUE;
    pub fn rb_reg_alloc() -> VALUE;
    pub fn rb_reg_init_str(re: VALUE, s: VALUE, options: ::libc::c_int)
     -> VALUE;
    pub fn rb_reg_match(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_reg_match2(arg1: VALUE) -> VALUE;
    pub fn rb_reg_options(arg1: VALUE) -> ::libc::c_int;
    pub fn rb_get_argv() -> VALUE;
    pub fn rb_load_file(arg1: *const ::libc::c_char) -> *mut ::libc::c_void;
    pub fn rb_load_file_str(arg1: VALUE) -> *mut ::libc::c_void;
    pub fn rb_f_kill(arg1: ::libc::c_int, arg2: *const VALUE) -> VALUE;
    pub fn ruby_posix_signal(arg1: ::libc::c_int,
                             arg2:
                                 ::std::option::Option<extern "C" fn(arg1:
                                                                         ::libc::c_int)
                                                           -> ()>)
     ->
         ::std::option::Option<extern "C" fn(arg1: ::libc::c_int,
                                             arg2:
                                                 ::std::option::Option<extern "C" fn(arg1:
                                                                                         ::libc::c_int)
                                                                           ->
                                                                               ()>)
                                   -> ()>;
    pub fn rb_trap_exit() -> ();
    pub fn rb_trap_exec() -> ();
    pub fn ruby_signal_name(arg1: ::libc::c_int) -> *const ::libc::c_char;
    pub fn ruby_default_signal(arg1: ::libc::c_int) -> ();
    pub fn rb_f_sprintf(arg1: ::libc::c_int, arg2: *const VALUE) -> VALUE;
    pub fn rb_sprintf(arg1: *const ::libc::c_char, ...) -> VALUE;
    pub fn rb_vsprintf(arg1: *const ::libc::c_char, arg2: va_list) -> VALUE;
    pub fn rb_str_catf(arg1: VALUE, arg2: *const ::libc::c_char, ...)
     -> VALUE;
    pub fn rb_str_vcatf(arg1: VALUE, arg2: *const ::libc::c_char,
                        arg3: va_list) -> VALUE;
    pub fn rb_str_format(arg1: ::libc::c_int, arg2: *const VALUE, arg3: VALUE)
     -> VALUE;
    pub fn rb_str_new(arg1: *const ::libc::c_char, arg2: ::libc::c_long)
     -> VALUE;
    pub fn rb_str_new_cstr(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_new_shared(arg1: VALUE) -> VALUE;
    pub fn rb_str_new_frozen(arg1: VALUE) -> VALUE;
    pub fn rb_str_new_with_class(arg1: VALUE, arg2: *const ::libc::c_char,
                                 arg3: ::libc::c_long) -> VALUE;
    pub fn rb_tainted_str_new_cstr(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_tainted_str_new(arg1: *const ::libc::c_char,
                              arg2: ::libc::c_long) -> VALUE;
    pub fn rb_external_str_new(arg1: *const ::libc::c_char,
                               arg2: ::libc::c_long) -> VALUE;
    pub fn rb_external_str_new_cstr(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_locale_str_new(arg1: *const ::libc::c_char,
                             arg2: ::libc::c_long) -> VALUE;
    pub fn rb_locale_str_new_cstr(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_filesystem_str_new(arg1: *const ::libc::c_char,
                                 arg2: ::libc::c_long) -> VALUE;
    pub fn rb_filesystem_str_new_cstr(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_buf_new(arg1: ::libc::c_long) -> VALUE;
    pub fn rb_str_buf_new_cstr(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_buf_new2(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_tmp_new(arg1: ::libc::c_long) -> VALUE;
    pub fn rb_usascii_str_new(arg1: *const ::libc::c_char,
                              arg2: ::libc::c_long) -> VALUE;
    pub fn rb_usascii_str_new_cstr(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_utf8_str_new(arg1: *const ::libc::c_char, arg2: ::libc::c_long)
     -> VALUE;
    pub fn rb_utf8_str_new_cstr(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_new_static(arg1: *const ::libc::c_char,
                             arg2: ::libc::c_long) -> VALUE;
    pub fn rb_usascii_str_new_static(arg1: *const ::libc::c_char,
                                     arg2: ::libc::c_long) -> VALUE;
    pub fn rb_utf8_str_new_static(arg1: *const ::libc::c_char,
                                  arg2: ::libc::c_long) -> VALUE;
    pub fn rb_str_free(arg1: VALUE) -> ();
    pub fn rb_str_shared_replace(arg1: VALUE, arg2: VALUE) -> ();
    pub fn rb_str_buf_append(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_buf_cat(arg1: VALUE, arg2: *const ::libc::c_char,
                          arg3: ::libc::c_long) -> VALUE;
    pub fn rb_str_buf_cat2(arg1: VALUE, arg2: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_buf_cat_ascii(arg1: VALUE, arg2: *const ::libc::c_char)
     -> VALUE;
    pub fn rb_obj_as_string(arg1: VALUE) -> VALUE;
    pub fn rb_check_string_type(arg1: VALUE) -> VALUE;
    pub fn rb_must_asciicompat(arg1: VALUE) -> ();
    pub fn rb_str_dup(arg1: VALUE) -> VALUE;
    pub fn rb_str_resurrect(str: VALUE) -> VALUE;
    pub fn rb_str_locktmp(arg1: VALUE) -> VALUE;
    pub fn rb_str_unlocktmp(arg1: VALUE) -> VALUE;
    pub fn rb_str_dup_frozen(arg1: VALUE) -> VALUE;
    pub fn rb_str_plus(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_times(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_sublen(arg1: VALUE, arg2: ::libc::c_long) -> ::libc::c_long;
    pub fn rb_str_substr(arg1: VALUE, arg2: ::libc::c_long,
                         arg3: ::libc::c_long) -> VALUE;
    pub fn rb_str_subseq(arg1: VALUE, arg2: ::libc::c_long,
                         arg3: ::libc::c_long) -> VALUE;
    pub fn rb_str_subpos(arg1: VALUE, arg2: ::libc::c_long,
                         arg3: *mut ::libc::c_long) -> *mut ::libc::c_char;
    pub fn rb_str_modify(arg1: VALUE) -> ();
    pub fn rb_str_modify_expand(arg1: VALUE, arg2: ::libc::c_long) -> ();
    pub fn rb_str_freeze(arg1: VALUE) -> VALUE;
    pub fn rb_str_set_len(arg1: VALUE, arg2: ::libc::c_long) -> ();
    pub fn rb_str_resize(arg1: VALUE, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_str_cat(arg1: VALUE, arg2: *const ::libc::c_char,
                      arg3: ::libc::c_long) -> VALUE;
    pub fn rb_str_cat_cstr(arg1: VALUE, arg2: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_cat2(arg1: VALUE, arg2: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_append(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_concat(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_memhash(ptr: *const ::libc::c_void, len: ::libc::c_long)
     -> st_index_t;
    pub fn rb_hash_start(arg1: st_index_t) -> st_index_t;
    pub fn rb_hash_uint32(arg1: st_index_t, arg2: uint32_t) -> st_index_t;
    pub fn rb_hash_uint(arg1: st_index_t, arg2: st_index_t) -> st_index_t;
    pub fn rb_hash_end(arg1: st_index_t) -> st_index_t;
    pub fn rb_str_hash(arg1: VALUE) -> st_index_t;
    pub fn rb_str_hash_cmp(arg1: VALUE, arg2: VALUE) -> ::libc::c_int;
    pub fn rb_str_comparable(arg1: VALUE, arg2: VALUE) -> ::libc::c_int;
    pub fn rb_str_cmp(arg1: VALUE, arg2: VALUE) -> ::libc::c_int;
    pub fn rb_str_equal(str1: VALUE, str2: VALUE) -> VALUE;
    pub fn rb_str_drop_bytes(arg1: VALUE, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_str_update(arg1: VALUE, arg2: ::libc::c_long,
                         arg3: ::libc::c_long, arg4: VALUE) -> ();
    pub fn rb_str_replace(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_str_inspect(arg1: VALUE) -> VALUE;
    pub fn rb_str_dump(arg1: VALUE) -> VALUE;
    pub fn rb_str_split(arg1: VALUE, arg2: *const ::libc::c_char) -> VALUE;
    pub fn rb_str_associate(arg1: VALUE, arg2: VALUE) -> ();
    pub fn rb_str_associated(arg1: VALUE) -> VALUE;
    pub fn rb_str_setter(arg1: VALUE, arg2: ID, arg3: *mut VALUE) -> ();
    pub fn rb_str_intern(arg1: VALUE) -> VALUE;
    pub fn rb_sym_to_s(arg1: VALUE) -> VALUE;
    pub fn rb_str_strlen(arg1: VALUE) -> ::libc::c_long;
    pub fn rb_str_length(arg1: VALUE) -> VALUE;
    pub fn rb_str_offset(arg1: VALUE, arg2: ::libc::c_long) -> ::libc::c_long;
    pub fn rb_str_capacity(arg1: VALUE) -> size_t;
    pub fn rb_str_ellipsize(arg1: VALUE, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_str_scrub(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_new(arg1: VALUE, ...) -> VALUE;
    pub fn rb_struct_define(arg1: *const ::libc::c_char, ...) -> VALUE;
    pub fn rb_struct_define_under(arg1: VALUE,
                                  arg2: *const ::libc::c_char, ...) -> VALUE;
    pub fn rb_struct_alloc(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_initialize(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_aref(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_struct_aset(arg1: VALUE, arg2: VALUE, arg3: VALUE) -> VALUE;
    pub fn rb_struct_getmember(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_struct_s_members(arg1: VALUE) -> VALUE;
    pub fn rb_struct_members(arg1: VALUE) -> VALUE;
    pub fn rb_struct_alloc_noinit(arg1: VALUE) -> VALUE;
    pub fn rb_struct_define_without_accessor(arg1: *const ::libc::c_char,
                                             arg2: VALUE,
                                             arg3: rb_alloc_func_t, ...)
     -> VALUE;
    pub fn rb_struct_define_without_accessor_under(outer: VALUE,
                                                   class_name:
                                                       *const ::libc::c_char,
                                                   _super: VALUE,
                                                   alloc:
                                                       rb_alloc_func_t, ...)
     -> VALUE;
    pub fn rb_thread_check_ints() -> ();
    pub fn rb_thread_interrupted(thval: VALUE) -> ::libc::c_int;
    pub fn rb_mutex_new() -> VALUE;
    pub fn rb_mutex_locked_p(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_trylock(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_lock(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_unlock(mutex: VALUE) -> VALUE;
    pub fn rb_mutex_sleep(_self: VALUE, timeout: VALUE) -> VALUE;
    pub fn rb_mutex_synchronize(mutex: VALUE,
                                func:
                                    ::std::option::Option<extern "C" fn(arg:
                                                                            VALUE)
                                                              -> VALUE>,
                                arg: VALUE) -> VALUE;
    pub fn rb_time_new(arg1: time_t, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_time_nano_new(arg1: time_t, arg2: ::libc::c_long) -> VALUE;
    pub fn rb_time_num_new(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_time_interval(num: VALUE) -> Struct_timeval;
    pub fn rb_time_timeval(time: VALUE) -> Struct_timeval;
    pub fn rb_time_timespec(time: VALUE) -> Struct_timespec;
    pub fn rb_mod_name(arg1: VALUE) -> VALUE;
    pub fn rb_class_path(arg1: VALUE) -> VALUE;
    pub fn rb_class_path_cached(arg1: VALUE) -> VALUE;
    pub fn rb_set_class_path(arg1: VALUE, arg2: VALUE,
                             arg3: *const ::libc::c_char) -> ();
    pub fn rb_set_class_path_string(arg1: VALUE, arg2: VALUE, arg3: VALUE)
     -> ();
    pub fn rb_path_to_class(arg1: VALUE) -> VALUE;
    pub fn rb_path2class(arg1: *const ::libc::c_char) -> VALUE;
    pub fn rb_name_class(arg1: VALUE, arg2: ID) -> ();
    pub fn rb_class_name(arg1: VALUE) -> VALUE;
    pub fn rb_autoload(arg1: VALUE, arg2: ID, arg3: *const ::libc::c_char)
     -> ();
    pub fn rb_autoload_load(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_autoload_p(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_f_trace_var(arg1: ::libc::c_int, arg2: *const VALUE) -> VALUE;
    pub fn rb_f_untrace_var(arg1: ::libc::c_int, arg2: *const VALUE) -> VALUE;
    pub fn rb_f_global_variables() -> VALUE;
    pub fn rb_alias_variable(arg1: ID, arg2: ID) -> ();
    pub fn rb_generic_ivar_table(arg1: VALUE) -> *mut Struct_st_table;
    pub fn rb_copy_generic_ivar(arg1: VALUE, arg2: VALUE) -> ();
    pub fn rb_free_generic_ivar(arg1: VALUE) -> ();
    pub fn rb_ivar_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_ivar_set(arg1: VALUE, arg2: ID, arg3: VALUE) -> VALUE;
    pub fn rb_ivar_defined(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_ivar_foreach(arg1: VALUE,
                           arg2:
                               ::std::option::Option<extern "C" fn()
                                                         -> ::libc::c_int>,
                           arg3: st_data_t) -> ();
    pub fn rb_ivar_count(arg1: VALUE) -> st_index_t;
    pub fn rb_attr_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_obj_instance_variables(arg1: VALUE) -> VALUE;
    pub fn rb_obj_remove_instance_variable(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_mod_const_at(arg1: VALUE, arg2: *mut ::libc::c_void)
     -> *mut ::libc::c_void;
    pub fn rb_mod_const_of(arg1: VALUE, arg2: *mut ::libc::c_void)
     -> *mut ::libc::c_void;
    pub fn rb_const_list(arg1: *mut ::libc::c_void) -> VALUE;
    pub fn rb_mod_constants(arg1: ::libc::c_int, arg2: *const VALUE,
                            arg3: VALUE) -> VALUE;
    pub fn rb_mod_remove_const(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_const_defined(arg1: VALUE, arg2: ID) -> ::libc::c_int;
    pub fn rb_const_defined_at(arg1: VALUE, arg2: ID) -> ::libc::c_int;
    pub fn rb_const_defined_from(arg1: VALUE, arg2: ID) -> ::libc::c_int;
    pub fn rb_const_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_const_get_at(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_const_get_from(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_const_set(arg1: VALUE, arg2: ID, arg3: VALUE) -> ();
    pub fn rb_const_remove(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_mod_const_missing(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_cvar_defined(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_cvar_set(arg1: VALUE, arg2: ID, arg3: VALUE) -> ();
    pub fn rb_cvar_get(arg1: VALUE, arg2: ID) -> VALUE;
    pub fn rb_cv_set(arg1: VALUE, arg2: *const ::libc::c_char, arg3: VALUE)
     -> ();
    pub fn rb_cv_get(arg1: VALUE, arg2: *const ::libc::c_char) -> VALUE;
    pub fn rb_define_class_variable(arg1: VALUE, arg2: *const ::libc::c_char,
                                    arg3: VALUE) -> ();
    pub fn rb_mod_class_variables(arg1: ::libc::c_int, arg2: *const VALUE,
                                  arg3: VALUE) -> VALUE;
    pub fn rb_mod_remove_cvar(arg1: VALUE, arg2: VALUE) -> VALUE;
    pub fn rb_frame_callee() -> ID;
    pub fn rb_str_succ(arg1: VALUE) -> VALUE;
    pub fn rb_time_succ(arg1: VALUE) -> VALUE;
    pub fn rb_frame_method_id_and_class(idp: *mut ID, klassp: *mut VALUE)
     -> ::libc::c_int;
    pub fn rb_make_backtrace() -> VALUE;
    pub fn rb_make_exception(arg1: ::libc::c_int, arg2: *const VALUE)
     -> VALUE;
    pub fn rb_frame_pop() -> ();
    pub fn ruby_native_thread_p() -> ::libc::c_int;
    pub fn rb_add_event_hook(func: rb_event_hook_func_t,
                             events: rb_event_flag_t, data: VALUE) -> ();
    pub fn rb_remove_event_hook(func: rb_event_hook_func_t) -> ::libc::c_int;
    pub fn rb_isalnum(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isalpha(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isblank(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_iscntrl(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isdigit(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isgraph(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_islower(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isprint(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_ispunct(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isspace(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isupper(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_isxdigit(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_tolower(c: ::libc::c_int) -> ::libc::c_int;
    pub fn rb_toupper(c: ::libc::c_int) -> ::libc::c_int;
    pub fn ruby_strtoul(str: *const ::libc::c_char,
                        endptr: *mut *mut ::libc::c_char, base: ::libc::c_int)
     -> ::libc::c_ulong;
    pub fn ruby_snprintf(str: *mut ::libc::c_char, n: size_t,
                         fmt: *const ::libc::c_char, ...) -> ::libc::c_int;
    pub fn ruby_vsnprintf(str: *mut ::libc::c_char, n: size_t,
                          fmt: *const ::libc::c_char, ap: va_list)
     -> ::libc::c_int;
    pub fn ruby_sysinit(argc: *mut ::libc::c_int,
                        argv: *mut *mut *mut ::libc::c_char) -> ();
    pub fn ruby_init() -> ();
    pub fn ruby_options(argc: ::libc::c_int, argv: *mut *mut ::libc::c_char)
     -> *mut ::libc::c_void;
    pub fn ruby_executable_node(n: *mut ::libc::c_void,
                                status: *mut ::libc::c_int) -> ::libc::c_int;
    pub fn ruby_run_node(n: *mut ::libc::c_void) -> ::libc::c_int;
    pub fn ruby_show_version() -> ();
    pub fn ruby_show_copyright() -> ();
    pub fn ruby_init_stack(arg1: *mut VALUE) -> ();
    pub fn ruby_setup() -> ::libc::c_int;
    pub fn ruby_cleanup(arg1: ::libc::c_int) -> ::libc::c_int;
    pub fn ruby_finalize() -> ();
    pub fn ruby_stop(arg1: ::libc::c_int) -> ();
    pub fn ruby_set_stack_size(arg1: size_t) -> ();
    pub fn ruby_stack_check() -> ::libc::c_int;
    pub fn ruby_stack_length(arg1: *mut *mut VALUE) -> size_t;
    pub fn ruby_exec_node(n: *mut ::libc::c_void) -> ::libc::c_int;
    pub fn ruby_script(name: *const ::libc::c_char) -> ();
    pub fn ruby_set_script_name(name: VALUE) -> ();
    pub fn ruby_prog_init() -> ();
    pub fn ruby_set_argv(arg1: ::libc::c_int, arg2: *mut *mut ::libc::c_char)
     -> ();
    pub fn ruby_process_options(arg1: ::libc::c_int,
                                arg2: *mut *mut ::libc::c_char)
     -> *mut ::libc::c_void;
    pub fn ruby_init_loadpath() -> ();
    pub fn ruby_incpush(arg1: *const ::libc::c_char) -> ();
    pub fn ruby_sig_finalize() -> ();
}
